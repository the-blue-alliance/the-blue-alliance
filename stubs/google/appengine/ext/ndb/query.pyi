import six
from google.appengine.datastore import datastore_query
from google.appengine.ext.ndb import context, Future, Key, Model
from typing import Any, Generic, Generator, Iterable, Literal, List, Optional, overload, TypeVar

Cursor: Any

T = TypeVar("T", bound=Model)

class QueryOptions(context.ContextOptions, datastore_query.QueryOptions): ...

class RepeatedStructuredPropertyPredicate(datastore_query.FilterPredicate):
    match_keys: Any
    match_values: Any
    def __init__(self, match_keys, pb, key_prefix) -> None: ...

class ParameterizedThing:
    def __eq__(self, other): ...
    def __ne__(self, other): ...

class Parameter(ParameterizedThing):
    def __init__(self, key) -> None: ...
    def __eq__(self, other): ...
    @property
    def key(self): ...
    def resolve(self, bindings, used): ...

class ParameterizedFunction(ParameterizedThing):
    def __init__(self, func, values) -> None: ...
    def __eq__(self, other): ...
    @property
    def func(self): ...
    @property
    def values(self): ...
    def is_parameterized(self): ...
    def resolve(self, bindings, used): ...

class Node:
    def __new__(cls): ...
    def __eq__(self, other): ...
    def __ne__(self, other): ...
    __le__: Any
    __lt__: Any
    __ge__: Any
    __gt__: Any
    def resolve(self, bindings, used): ...

class FalseNode(Node):
    def __eq__(self, other): ...

class ParameterNode(Node):
    def __new__(cls, prop, op, param): ...
    def __getnewargs__(self): ...
    def __eq__(self, other): ...
    def resolve(self, bindings, used): ...

class FilterNode(Node):
    def __new__(cls, name, opsymbol, value): ...
    def __getnewargs__(self): ...
    def __eq__(self, other): ...
    def __hash__(self): ...

class PostFilterNode(Node):
    predicate: Any
    def __new__(cls, predicate): ...
    def __getnewargs__(self): ...
    def __eq__(self, other): ...

class ConjunctionNode(Node):
    def __new__(cls, *nodes): ...
    def __getnewargs__(self): ...
    def __iter__(self): ...
    def __eq__(self, other): ...
    def resolve(self, bindings, used): ...

class DisjunctionNode(Node):
    def __new__(cls, *nodes): ...
    def __getnewargs__(self): ...
    def __iter__(self): ...
    def __eq__(self, other): ...
    def resolve(self, bindings, used): ...
AND = ConjunctionNode
OR = DisjunctionNode

class Query(Generic[T]):
    def __init__(self, kind: Any | None = ..., ancestor: Any | None = ..., filters: Any | None = ..., orders: Any | None = ..., app: Any | None = ..., namespace: Any | None = ..., default_options: Any | None = ..., projection: Any | None = ..., group_by: Any | None = ...) -> None: ...
    def run_to_queue(self, queue, conn, options: Any | None = ..., dsquery: Any | None = ...) -> None: ...
    @property
    def kind(self): ...
    @property
    def ancestor(self): ...
    @property
    def filters(self): ...
    @property
    def orders(self): ...
    @property
    def app(self): ...
    @property
    def namespace(self): ...
    @property
    def default_options(self): ...
    @property
    def group_by(self): ...
    @property
    def projection(self): ...
    @property
    def is_distinct(self): ...

    def filter(self, *args) -> "Query[T]": ...

    def order(self, *args) -> "Query[T]": ...

    def iter(self, **q_options): ...
    __iter__: Any
    def map(self, callback, pass_batch_into_callback: Any | None = ..., merge_future: Any | None = ..., **q_options): ...
    def map_async(self, callback, pass_batch_into_callback: Any | None = ..., merge_future: Any | None = ..., **q_options): ...

    @overload
    def fetch(self, keys_only: Literal[True], **q_options) -> List[Key]: ...

    @overload
    def fetch(self, limit: Optional[int] = None, **q_options) -> List[T]: ...

    @overload
    def fetch_async(self, limit: Optional[int] = None, **q_options) -> Future[List[T]]:

    @overload
    def fetch_async(self, keys_ony: Literal[True], **q_options) -> Future[List[Key]]: ...

    def get(self, **q_options) -> T: ...
    def get_async(self, **q_options) -> Future[T]: ...
    def count(self, limit: Any | None = ..., **q_options): ...
    def count_async(self, limit: Any | None = ..., **q_options): ...
    def fetch_page(self, page_size, **q_options): ...
    def fetch_page_async(self, page_size, **q_options): ...
    def analyze(self): ...
    def bind(self, *args, **kwds): ...

def gql(query_string, *args, **kwds): ...

class QueryIterator(six.Iterator):
    def __init__(self, query, **q_options) -> None: ...
    def cursor_before(self): ...
    def cursor_after(self): ...
    def index_list(self): ...
    def __iter__(self): ...
    def probably_has_next(self): ...
    def has_next(self): ...
    def has_next_async(self) -> None: ...
    def __next__(self): ...

class _SubQueryIteratorState:
    batch: Any
    index: Any
    entity: Any
    iterator: Any
    dsquery: Any
    orders: Any
    def __init__(self, batch_i_entity, iterator, dsquery, orders) -> None: ...
    def __cmp__(self, other): ...

class _MultiQuery:
    ancestor: Any
    def __init__(self, subqueries) -> None: ...
    @property
    def orders(self): ...
    @property
    def default_options(self): ...
    def run_to_queue(self, queue, conn, options: Any | None = ...) -> None: ...
    def iter(self, **q_options): ...
    __iter__: Any

import ast
import py
from _pytest.compat import (
    TYPE_CHECKING as TYPE_CHECKING,
    get_real_func as get_real_func,
    overload as overload,
)
from types import CodeType, FrameType
from typing import Any, Iterator, List, Optional, Sequence, Tuple, Union
from typing_extensions import Literal as Literal

class Source:
    lines: Any = ...
    def __init__(self, *parts: Any, **kwargs: Any) -> None: ...
    def __eq__(self, other: Any) -> Any: ...
    __hash__: Any = ...
    def __getitem__(self, key: int) -> str: ...
    def __getitem__(self, key: slice) -> Source: ...
    def __getitem__(self, key: Union[int, slice]) -> Union[str, Source]: ...
    def __iter__(self) -> Iterator[str]: ...
    def __len__(self) -> int: ...
    def strip(self) -> Source: ...
    def putaround(
        self, before: str = ..., after: str = ..., indent: str = ...
    ) -> Source: ...
    def indent(self, indent: str = ...) -> Source: ...
    def getstatement(self, lineno: int) -> Source: ...
    def getstatementrange(self, lineno: int) -> Tuple[int, int]: ...
    def deindent(self) -> Source: ...
    def isparseable(self, deindent: bool = ...) -> bool: ...
    def compile(
        self,
        filename: Optional[str] = ...,
        mode: str = ...,
        flag: Literal[0] = ...,
        dont_inherit: int = ...,
        _genframe: Optional[FrameType] = ...,
    ) -> CodeType: ...
    def compile(
        self,
        filename: Optional[str] = ...,
        mode: str = ...,
        flag: int = ...,
        dont_inherit: int = ...,
        _genframe: Optional[FrameType] = ...,
    ) -> Union[CodeType, ast.AST]: ...
    def compile(
        self,
        filename: Optional[str] = ...,
        mode: str = ...,
        flag: int = ...,
        dont_inherit: int = ...,
        _genframe: Optional[FrameType] = ...,
    ) -> Union[CodeType, ast.AST]: ...

def compile_(
    source: Union[str, bytes, ast.mod, ast.AST],
    filename: Optional[str] = ...,
    mode: str = ...,
    flags: Literal[0] = ...,
    dont_inherit: int = ...,
) -> CodeType: ...
def getfslineno(obj: Any) -> Tuple[Union[str, py.path.local], int]: ...
def findsource(obj: Any) -> Tuple[Optional[Source], int]: ...
def getsource(obj: Any, **kwargs: Any) -> Source: ...
def deindent(lines: Sequence[str]) -> List[str]: ...
def get_statement_startend2(
    lineno: int, node: ast.AST
) -> Tuple[int, Optional[int]]: ...
def getstatementrange_ast(
    lineno: int, source: Source, assertion: bool = ..., astnode: Optional[ast.AST] = ...
) -> Tuple[ast.AST, int, int]: ...

import py
import typing
from _pytest import fixtures as fixtures, nodes as nodes
from _pytest._code import filter_traceback as filter_traceback
from _pytest._code.code import ExceptionInfo as ExceptionInfo
from _pytest._code.source import getfslineno as getfslineno
from _pytest._io import TerminalWriter as TerminalWriter
from _pytest._io.saferepr import saferepr as saferepr
from _pytest.compat import NOTSET as NOTSET, REGEX_TYPE as REGEX_TYPE, STRING_TYPES as STRING_TYPES, ascii_escaped as ascii_escaped, get_default_arg_names as get_default_arg_names, get_real_func as get_real_func, getimfunc as getimfunc, getlocation as getlocation, is_async_function as is_async_function, is_generator as is_generator, safe_getattr as safe_getattr, safe_isclass as safe_isclass
from _pytest.config import Config as Config, hookimpl as hookimpl
from _pytest.deprecated import FUNCARGNAMES as FUNCARGNAMES
from _pytest.fixtures import FuncFixtureInfo as FuncFixtureInfo
from _pytest.mark import MARK_GEN as MARK_GEN, ParameterSet as ParameterSet
from _pytest.mark.structures import Mark as Mark, get_unpacked_marks as get_unpacked_marks, normalize_mark_list as normalize_mark_list
from _pytest.outcomes import fail as fail, skip as skip
from _pytest.pathlib import parts as parts
from _pytest.warning_types import PytestCollectionWarning as PytestCollectionWarning, PytestUnhandledCoroutineWarning as PytestUnhandledCoroutineWarning
from typing import Any, Callable, Iterable, List, Optional, Tuple, Union

def pyobj_property(name: Any): ...
def pytest_addoption(parser: Any) -> None: ...
def pytest_cmdline_main(config: Any): ...
def pytest_generate_tests(metafunc: Metafunc) -> None: ...
def pytest_configure(config: Any) -> None: ...
def async_warn_and_skip(nodeid: str) -> None: ...
def pytest_pyfunc_call(pyfuncitem: Function) -> Any: ...
def pytest_collect_file(path: Any, parent: Any): ...
def path_matches_patterns(path: Any, patterns: Any): ...
def pytest_pycollect_makemodule(path: Any, parent: Any): ...
def pytest_pycollect_makeitem(collector: Any, name: Any, obj: Any) -> None: ...

class PyobjMixin:
    module: Any = ...
    cls: Any = ...
    instance: Any = ...
    @property
    def obj(self): ...
    @obj.setter
    def obj(self, value: Any) -> None: ...
    def getmodpath(self, stopatmodule: bool = ..., includemodule: bool = ...): ...
    def reportinfo(self) -> Tuple[Union[py.path.local, str], int, str]: ...

class PyCollector(PyobjMixin, nodes.Collector):
    def funcnamefilter(self, name: Any): ...
    def isnosetest(self, obj: Any): ...
    def classnamefilter(self, name: Any): ...
    def istestfunction(self, obj: Any, name: Any): ...
    def istestclass(self, obj: Any, name: Any): ...
    def collect(self): ...

class Module(nodes.File, PyCollector):
    def collect(self): ...

class Package(Module):
    name: Any = ...
    def __init__(self, fspath: py.path.local, parent: nodes.Collector, config: Any=..., session: Any=..., nodeid: Any=...) -> None: ...
    def setup(self) -> None: ...
    def gethookproxy(self, fspath: py.path.local) -> Any: ...
    def isinitpath(self, path: Any): ...
    def collect(self) -> None: ...

class Class(PyCollector):
    @classmethod
    def from_parent(cls, parent: Any, name: Any, *, obj: Optional[Any] = ...): ...
    def collect(self): ...

class Instance(PyCollector):
    def collect(self): ...
    obj: Any = ...
    def newinstance(self): ...

def hasinit(obj: Any): ...
def hasnew(obj: Any): ...

class CallSpec2:
    metafunc: Any = ...
    funcargs: Any = ...
    params: Any = ...
    marks: Any = ...
    indices: Any = ...
    def __init__(self, metafunc: Any) -> None: ...
    def copy(self): ...
    def getparam(self, name: Any): ...
    @property
    def id(self): ...
    def setmulti2(self, valtypes: Any, argnames: Any, valset: Any, id: Any, marks: Any, scopenum: Any, param_index: Any) -> None: ...

class Metafunc:
    definition: Any = ...
    config: Any = ...
    module: Any = ...
    function: Any = ...
    fixturenames: Any = ...
    cls: Any = ...
    def __init__(self, definition: FunctionDefinition, fixtureinfo: fixtures.FuncFixtureInfo, config: Config, cls: Any=..., module: Any=...) -> None: ...
    @property
    def funcargnames(self): ...
    def parametrize(self, argnames: Union[str, List[str], Tuple[str, ...]], argvalues: Iterable[Union[ParameterSet, typing.Sequence[object], object]], indirect: Union[bool, typing.Sequence[str]]=..., ids: Optional[Union[Iterable[Union[None, str, float, int, bool]], Callable[[object], Optional[object]]]]=..., scope: Optional[str]=..., *, _param_mark: Optional[Mark]=...) -> None: ...

def idmaker(argnames: Iterable[str], parametersets: Iterable[ParameterSet], idfn: Optional[Callable[[object], Optional[object]]]=..., ids: Optional[List[Union[None, str]]]=..., config: Optional[Config]=..., item: Any=...) -> List[str]: ...
def show_fixtures_per_test(config: Any): ...
def showfixtures(config: Any): ...
def write_docstring(tw: TerminalWriter, doc: str, indent: str=...) -> None: ...

class Function(PyobjMixin, nodes.Item):
    obj: Any = ...
    callspec: Any = ...
    fixturenames: Any = ...
    originalname: Any = ...
    def __init__(self, name: Any, parent: Any, args: Any=..., config: Any=..., callspec: Optional[CallSpec2]=..., callobj: Any=..., keywords: Any=..., session: Any=..., fixtureinfo: Optional[FuncFixtureInfo]=..., originalname: Any=...) -> None: ...
    @classmethod
    def from_parent(cls, parent: Any, **kw: Any): ...
    @property
    def function(self): ...
    @property
    def funcargnames(self): ...
    def runtest(self) -> None: ...
    def setup(self) -> None: ...
    def repr_failure(self, excinfo: Any, outerr: Optional[Any] = ...): ...

class FunctionDefinition(Function):
    def runtest(self) -> None: ...
    setup: Any = ...

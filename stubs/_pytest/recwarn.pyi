import warnings
from _pytest.compat import TYPE_CHECKING as TYPE_CHECKING, overload as overload
from _pytest.fixtures import yield_fixture as yield_fixture
from _pytest.outcomes import fail as fail
from types import TracebackType
from typing import Any, Iterator, List, Optional, Pattern, Tuple, Type, Union

def recwarn() -> None: ...
def deprecated_call(func: Optional[Any] = ..., *args: Any, **kwargs: Any): ...
def warns(expected_warning: Optional[Union[Type[Warning], Tuple[Type[Warning], ...]]], *, match: Optional[Union[str, Pattern]]=...) -> WarningsChecker: ...

class WarningsRecorder(warnings.catch_warnings):
    def __init__(self) -> None: ...
    @property
    def list(self) -> List[warnings._Record]: ...
    def __getitem__(self, i: int) -> warnings._Record: ...
    def __iter__(self) -> Iterator[warnings._Record]: ...
    def __len__(self) -> int: ...
    def pop(self, cls: Type[Warning]=...) -> warnings._Record: ...
    def clear(self) -> None: ...
    def __enter__(self) -> WarningsRecorder: ...
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[TracebackType]) -> None: ...

class WarningsChecker(WarningsRecorder):
    expected_warning: Any = ...
    match_expr: Any = ...
    def __init__(self, expected_warning: Optional[Union[Type[Warning], Tuple[Type[Warning], ...]]]=..., match_expr: Optional[Union[str, Pattern]]=...) -> None: ...
    def __exit__(self, exc_type: Optional[Type[BaseException]], exc_val: Optional[BaseException], exc_tb: Optional[TracebackType]) -> None: ...

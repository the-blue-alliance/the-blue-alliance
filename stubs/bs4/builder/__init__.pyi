from _typeshed import Incomplete
from bs4 import BeautifulSoup
from bs4._typing import _Encoding, _Encodings, _RawMarkup
from bs4.element import AttributeDict, AttributeValueList, NavigableString, Tag
from bs4.exceptions import ParserRejectedMarkup as ParserRejectedMarkup
from typing import Any, Iterable, Pattern

__all__ = ['TreeBuilderRegistry', 'TreeBuilder', 'HTMLTreeBuilder', 'DetectsXMLParsedAsHTML', 'ParserRejectedMarkup', 'HTMLParserTreeBuilder']

class TreeBuilderRegistry:
    builders_for_feature: dict[str, list[type[TreeBuilder]]]
    builders: list[type[TreeBuilder]]
    def __init__(self) -> None: ...
    def register(self, treebuilder_class: type[TreeBuilder]) -> None: ...
    def lookup(self, *features: str) -> type[TreeBuilder] | None: ...

class TreeBuilder:
    USE_DEFAULT: Any
    soup: Incomplete
    cdata_list_attributes: Incomplete
    preserve_whitespace_tags: Incomplete
    empty_element_tags: Incomplete
    store_line_numbers: Incomplete
    string_containers: Incomplete
    attribute_dict_class: Incomplete
    attribute_value_list_class: Incomplete
    def __init__(self, multi_valued_attributes: dict[str, set[str]] = ..., preserve_whitespace_tags: set[str] = ..., store_line_numbers: bool = ..., string_containers: dict[str, type[NavigableString]] = ..., empty_element_tags: set[str] = ..., attribute_dict_class: type[AttributeDict] = ..., attribute_value_list_class: type[AttributeValueList] = ...) -> None: ...
    NAME: str
    ALTERNATE_NAMES: Iterable[str]
    features: Iterable[str]
    is_xml: bool
    picklable: bool
    tracks_line_numbers: bool
    DEFAULT_CDATA_LIST_ATTRIBUTES: dict[str, set[str]]
    DEFAULT_PRESERVE_WHITESPACE_TAGS: set[str]
    DEFAULT_STRING_CONTAINERS: dict[str, type[bs4.element.NavigableString]]
    DEFAULT_EMPTY_ELEMENT_TAGS: set[str] | None
    TRACKS_LINE_NUMBERS: bool
    def initialize_soup(self, soup: BeautifulSoup) -> None: ...
    def reset(self) -> None: ...
    def can_be_empty_element(self, tag_name: str) -> bool: ...
    def feed(self, markup: _RawMarkup) -> None: ...
    def prepare_markup(self, markup: _RawMarkup, user_specified_encoding: _Encoding | None = None, document_declared_encoding: _Encoding | None = None, exclude_encodings: _Encodings | None = None) -> Iterable[tuple[_RawMarkup, _Encoding | None, _Encoding | None, bool]]: ...
    def test_fragment_to_document(self, fragment: str) -> str: ...
    def set_up_substitutions(self, tag: Tag) -> bool: ...

class SAXTreeBuilder(TreeBuilder):
    def __init__(self, *args: Any, **kwargs: Any) -> None: ...
    def feed(self, markup: _RawMarkup) -> None: ...
    def close(self) -> None: ...
    def startElement(self, name: str, attrs: dict[str, str]) -> None: ...
    def endElement(self, name: str) -> None: ...
    def startElementNS(self, nsTuple: tuple[str, str], nodeName: str, attrs: dict[str, str]) -> None: ...
    def endElementNS(self, nsTuple: tuple[str, str], nodeName: str) -> None: ...
    def startPrefixMapping(self, prefix: str, nodeValue: str) -> None: ...
    def endPrefixMapping(self, prefix: str) -> None: ...
    def characters(self, content: str) -> None: ...
    def startDocument(self) -> None: ...
    def endDocument(self) -> None: ...

class HTMLTreeBuilder(TreeBuilder):
    DEFAULT_EMPTY_ELEMENT_TAGS: set[str]
    DEFAULT_BLOCK_ELEMENTS: set[str]
    DEFAULT_STRING_CONTAINERS: dict[str, type[bs4.element.NavigableString]]
    DEFAULT_CDATA_LIST_ATTRIBUTES: dict[str, set[str]]
    DEFAULT_PRESERVE_WHITESPACE_TAGS: set[str]
    def set_up_substitutions(self, tag: Tag) -> bool: ...

class DetectsXMLParsedAsHTML:
    LOOKS_LIKE_HTML: Pattern[str]
    LOOKS_LIKE_HTML_B: Pattern[bytes]
    XML_PREFIX: str
    XML_PREFIX_B: bytes
    @classmethod
    def warn_if_markup_looks_like_xml(cls, markup: _RawMarkup | None, stacklevel: int = 3) -> bool: ...

# Names in __all__ with no definition:
#   HTMLParserTreeBuilder

from _typeshed import Incomplete
from bs4 import BeautifulSoup as BeautifulSoup
from bs4._typing import _AtMostOneElement, _AttributeValue, _Encoding, _InsertableElement, _OneElement, _QueryResults, _RawOrProcessedAttributeValues, _StrainableAttribute, _StrainableAttributes, _StrainableElement, _StrainableString
from bs4._warnings import AttributeResemblesVariableWarning as AttributeResemblesVariableWarning
from bs4.builder import TreeBuilder as TreeBuilder
from bs4.css import CSS as CSS
from bs4.filter import ElementFilter as ElementFilter, SoupStrainer as SoupStrainer
from bs4.formatter import Formatter as Formatter, HTMLFormatter as HTMLFormatter, XMLFormatter as XMLFormatter, _EntitySubstitutionFunction, _FormatterOrName
from typing import Any, Generic, Iterable, Iterator, Pattern
from typing_extensions import Self

def __getattr__(name: str) -> Any: ...

DEFAULT_OUTPUT_ENCODING: str
nonwhitespace_re: Pattern[str]
PYTHON_SPECIFIC_ENCODINGS: set[_Encoding]

class NamespacedAttribute(str):
    prefix: str | None
    name: str | None
    namespace: str | None
    def __new__(cls, prefix: str | None, name: str | None = None, namespace: str | None = None) -> Self: ...

class AttributeValueWithCharsetSubstitution(str):
    original_value: str
    def substitute_encoding(self, eventual_encoding: str) -> str: ...

class CharsetMetaAttributeValue(AttributeValueWithCharsetSubstitution):
    def __new__(cls, original_value: str) -> Self: ...
    def substitute_encoding(self, eventual_encoding: _Encoding = 'utf-8') -> str: ...

class AttributeValueList(list[str]): ...
class AttributeDict(dict[Any, Any]): ...

class XMLAttributeDict(AttributeDict):
    def __setitem__(self, key: str, value: Any) -> None: ...

class HTMLAttributeDict(AttributeDict):
    def __setitem__(self, key: str, value: Any) -> None: ...

class ContentMetaAttributeValue(AttributeValueWithCharsetSubstitution):
    CHARSET_RE: Pattern[str]
    def __new__(cls, original_value: str) -> Self: ...
    def substitute_encoding(self, eventual_encoding: _Encoding = 'utf-8') -> str: ...

class PageElement:
    known_xml: bool | None
    parent: Tag | None
    next_element: _AtMostOneElement
    previous_element: _AtMostOneElement
    next_sibling: _AtMostOneElement
    previous_sibling: _AtMostOneElement
    hidden: bool
    def setup(self, parent: Tag | None = None, previous_element: _AtMostOneElement = None, next_element: _AtMostOneElement = None, previous_sibling: _AtMostOneElement = None, next_sibling: _AtMostOneElement = None) -> None: ...
    def format_string(self, s: str, formatter: _FormatterOrName | None) -> str: ...
    def formatter_for_name(self, formatter_name: _FormatterOrName | _EntitySubstitutionFunction) -> Formatter: ...
    nextSibling: Incomplete
    previousSibling: Incomplete
    def __deepcopy__(self, memo: dict[Any, Any], recursive: bool = False) -> Self: ...
    def __copy__(self) -> Self: ...
    default: Iterable[type[NavigableString]]
    @property
    def stripped_strings(self) -> Iterator[str]: ...
    def get_text(self, separator: str = '', strip: bool = False, types: Iterable[type[NavigableString]] = ...) -> str: ...
    getText = get_text
    text: Incomplete
    def replace_with(self, *args: PageElement) -> Self: ...
    replaceWith: Incomplete
    def wrap(self, wrap_inside: Tag) -> Tag: ...
    def extract(self, _self_index: int | None = None) -> Self: ...
    def decompose(self) -> None: ...
    def insert_before(self, *args: _InsertableElement) -> list[PageElement]: ...
    def insert_after(self, *args: _InsertableElement) -> list[PageElement]: ...
    def find_next(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, string: _StrainableString | None = None, **kwargs: _StrainableAttribute) -> _AtMostOneElement: ...
    findNext: Incomplete
    def find_all_next(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, string: _StrainableString | None = None, limit: int | None = None, _stacklevel: int = 2, **kwargs: _StrainableAttribute) -> _QueryResults: ...
    findAllNext: Incomplete
    def find_next_sibling(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, string: _StrainableString | None = None, **kwargs: _StrainableAttribute) -> _AtMostOneElement: ...
    findNextSibling: Incomplete
    def find_next_siblings(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, string: _StrainableString | None = None, limit: int | None = None, _stacklevel: int = 2, **kwargs: _StrainableAttribute) -> _QueryResults: ...
    findNextSiblings: Incomplete
    fetchNextSiblings: Incomplete
    def find_previous(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, string: _StrainableString | None = None, **kwargs: _StrainableAttribute) -> _AtMostOneElement: ...
    findPrevious: Incomplete
    def find_all_previous(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, string: _StrainableString | None = None, limit: int | None = None, _stacklevel: int = 2, **kwargs: _StrainableAttribute) -> _QueryResults: ...
    findAllPrevious: Incomplete
    fetchAllPrevious: Incomplete
    def find_previous_sibling(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, string: _StrainableString | None = None, **kwargs: _StrainableAttribute) -> _AtMostOneElement: ...
    findPreviousSibling: Incomplete
    def find_previous_siblings(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, string: _StrainableString | None = None, limit: int | None = None, _stacklevel: int = 2, **kwargs: _StrainableAttribute) -> _QueryResults: ...
    findPreviousSiblings: Incomplete
    fetchPreviousSiblings: Incomplete
    def find_parent(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, **kwargs: _StrainableAttribute) -> _AtMostOneElement: ...
    findParent: Incomplete
    def find_parents(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, limit: int | None = None, _stacklevel: int = 2, **kwargs: _StrainableAttribute) -> _QueryResults: ...
    findParents: Incomplete
    fetchParents: Incomplete
    @property
    def next(self) -> _AtMostOneElement: ...
    @property
    def previous(self) -> _AtMostOneElement: ...
    @property
    def next_elements(self) -> Iterator[PageElement]: ...
    @property
    def self_and_next_elements(self) -> Iterator[PageElement]: ...
    @property
    def next_siblings(self) -> Iterator[PageElement]: ...
    @property
    def self_and_next_siblings(self) -> Iterator[PageElement]: ...
    @property
    def previous_elements(self) -> Iterator[PageElement]: ...
    @property
    def self_and_previous_elements(self) -> Iterator[PageElement]: ...
    @property
    def previous_siblings(self) -> Iterator[PageElement]: ...
    @property
    def self_and_previous_siblings(self) -> Iterator[PageElement]: ...
    @property
    def parents(self) -> Iterator[Tag]: ...
    @property
    def self_and_parents(self) -> Iterator[PageElement]: ...
    @property
    def decomposed(self) -> bool: ...
    def nextGenerator(self) -> Iterator[PageElement]: ...
    def nextSiblingGenerator(self) -> Iterator[PageElement]: ...
    def previousGenerator(self) -> Iterator[PageElement]: ...
    def previousSiblingGenerator(self) -> Iterator[PageElement]: ...
    def parentGenerator(self) -> Iterator[PageElement]: ...

class NavigableString(str, PageElement):
    PREFIX: str
    SUFFIX: str
    def __new__(cls, value: str | bytes) -> Self: ...
    def __deepcopy__(self, memo: dict[Any, Any], recursive: bool = False) -> Self: ...
    def __getnewargs__(self) -> tuple[str]: ...
    @property
    def string(self) -> str: ...
    def output_ready(self, formatter: _FormatterOrName = 'minimal') -> str: ...
    @property
    def name(self) -> None: ...
    @name.setter
    def name(self, name: str) -> None: ...
    @property
    def strings(self) -> Iterator[str]: ...

class PreformattedString(NavigableString):
    PREFIX: str
    SUFFIX: str
    def output_ready(self, formatter: _FormatterOrName | None = None) -> str: ...

class CData(PreformattedString):
    PREFIX: str
    SUFFIX: str

class ProcessingInstruction(PreformattedString):
    PREFIX: str
    SUFFIX: str

class XMLProcessingInstruction(ProcessingInstruction):
    PREFIX: str
    SUFFIX: str

class Comment(PreformattedString):
    PREFIX: str
    SUFFIX: str

class Declaration(PreformattedString):
    PREFIX: str
    SUFFIX: str

class Doctype(PreformattedString):
    @classmethod
    def for_name_and_ids(cls, name: str, pub_id: str | None, system_id: str | None) -> Doctype: ...
    PREFIX: str
    SUFFIX: str

class Stylesheet(NavigableString): ...
class Script(NavigableString): ...
class TemplateString(NavigableString): ...
class RubyTextString(NavigableString): ...
class RubyParenthesisString(NavigableString): ...

class Tag(PageElement):
    parser_class: Incomplete
    name: Incomplete
    namespace: Incomplete
    prefix: Incomplete
    sourceline: Incomplete
    sourcepos: Incomplete
    attribute_value_list_class: Incomplete
    attrs: Incomplete
    known_xml: Incomplete
    contents: list[PageElement]
    hidden: bool
    can_be_empty_element: Incomplete
    cdata_list_attributes: Incomplete
    preserve_whitespace_tags: Incomplete
    interesting_string_types: Incomplete
    def __init__(self, parser: BeautifulSoup | None = None, builder: TreeBuilder | None = None, name: str | None = None, namespace: str | None = None, prefix: str | None = None, attrs: _RawOrProcessedAttributeValues | None = None, parent: BeautifulSoup | Tag | None = None, previous: _AtMostOneElement = None, is_xml: bool | None = None, sourceline: int | None = None, sourcepos: int | None = None, can_be_empty_element: bool | None = None, cdata_list_attributes: dict[str, set[str]] | None = None, preserve_whitespace_tags: set[str] | None = None, interesting_string_types: set[type[NavigableString]] | None = None, namespaces: dict[str, str] | None = None) -> None: ...
    parserClass: Incomplete
    def __deepcopy__(self, memo: dict[Any, Any], recursive: bool = True) -> Self: ...
    def copy_self(self) -> Self: ...
    @property
    def is_empty_element(self) -> bool: ...
    def isSelfClosing(self) -> bool: ...
    @property
    def string(self) -> str | None: ...
    @string.setter
    def string(self, string: str) -> None: ...
    MAIN_CONTENT_STRING_TYPES: Incomplete
    strings: Incomplete
    def insert(self, position: int, *new_children: _InsertableElement) -> list[PageElement]: ...
    def unwrap(self) -> Self: ...
    replace_with_children = unwrap
    def replaceWithChildren(self) -> _OneElement: ...
    def append(self, tag: _InsertableElement) -> PageElement: ...
    def extend(self, tags: Iterable[_InsertableElement] | Tag) -> list[PageElement]: ...
    def clear(self, decompose: bool = False) -> None: ...
    def smooth(self) -> None: ...
    def index(self, element: PageElement) -> int: ...
    def get(self, key: str, default: _AttributeValue | None = None) -> _AttributeValue | None: ...
    def get_attribute_list(self, key: str, default: AttributeValueList | None = None) -> AttributeValueList: ...
    def has_attr(self, key: str) -> bool: ...
    def __hash__(self) -> int: ...
    def __getitem__(self, key: str) -> _AttributeValue: ...
    def __iter__(self) -> Iterator[PageElement]: ...
    def __len__(self) -> int: ...
    def __contains__(self, x: Any) -> bool: ...
    def __bool__(self) -> bool: ...
    def __setitem__(self, key: str, value: _AttributeValue) -> None: ...
    def __delitem__(self, key: str) -> None: ...
    def __call__(self, name: _StrainableElement | None = None, attrs: _StrainableAttributes = {}, recursive: bool = True, string: _StrainableString | None = None, limit: int | None = None, _stacklevel: int = 2, **kwargs: _StrainableAttribute) -> _QueryResults: ...
    def __getattr__(self, subtag: str) -> Tag | None: ...
    def __eq__(self, other: Any) -> bool: ...
    def __ne__(self, other: Any) -> bool: ...
    __unicode__: Incomplete
    def encode(self, encoding: _Encoding = ..., indent_level: int | None = None, formatter: _FormatterOrName = 'minimal', errors: str = 'xmlcharrefreplace') -> bytes: ...
    def decode(self, indent_level: int | None = None, eventual_encoding: _Encoding = ..., formatter: _FormatterOrName = 'minimal', iterator: Iterator[PageElement] | None = None) -> str: ...
    class _TreeTraversalEvent: ...
    START_ELEMENT_EVENT: Incomplete
    END_ELEMENT_EVENT: Incomplete
    EMPTY_ELEMENT_EVENT: Incomplete
    STRING_ELEMENT_EVENT: Incomplete
    def prettify(self, encoding: _Encoding | None = None, formatter: _FormatterOrName = 'minimal') -> str | bytes: ...
    def decode_contents(self, indent_level: int | None = None, eventual_encoding: _Encoding = ..., formatter: _FormatterOrName = 'minimal') -> str: ...
    def encode_contents(self, indent_level: int | None = None, encoding: _Encoding = ..., formatter: _FormatterOrName = 'minimal') -> bytes: ...
    def renderContents(self, encoding: _Encoding = ..., prettyPrint: bool = False, indentLevel: int | None = 0) -> bytes: ...
    def find(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, recursive: bool = True, string: _StrainableString | None = None, **kwargs: _StrainableAttribute) -> _AtMostOneElement: ...
    findChild: Incomplete
    def find_all(self, name: _FindMethodName = None, attrs: _StrainableAttributes = {}, recursive: bool = True, string: _StrainableString | None = None, limit: int | None = None, _stacklevel: int = 2, **kwargs: _StrainableAttribute) -> _QueryResults: ...
    findAll: Incomplete
    findChildren: Incomplete
    @property
    def children(self) -> Iterator[PageElement]: ...
    @property
    def self_and_descendants(self) -> Iterator[PageElement]: ...
    @property
    def descendants(self) -> Iterator[PageElement]: ...
    def select_one(self, selector: str, namespaces: dict[str, str] | None = None, **kwargs: Any) -> Tag | None: ...
    def select(self, selector: str, namespaces: dict[str, str] | None = None, limit: int = 0, **kwargs: Any) -> ResultSet[Tag]: ...
    @property
    def css(self) -> CSS: ...
    def childGenerator(self) -> Iterator[PageElement]: ...
    def recursiveChildGenerator(self) -> Iterator[PageElement]: ...
    def has_key(self, key: str) -> bool: ...

class ResultSet(list[_PageElementT], Generic[_PageElementT]):
    source: ElementFilter | None
    def __init__(self, source: ElementFilter | None, result: Iterable[_PageElementT] = ()) -> None: ...
    def __getattr__(self, key: str) -> None: ...
